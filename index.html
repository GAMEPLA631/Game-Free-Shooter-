<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roblox Shooting Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            color: #fff;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-left: -10px;
            margin-top: -10px;
            border: 2px solid white;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 5px 2px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 100;
        }

        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background-color: white;
            border-radius: 50%;
        }

        #sniper-scope {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none; /* Initially hidden */
            z-index: 101;
            pointer-events: none;
        }

        #scope-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vh;
            height: 100vh;
            border-radius: 50%;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.8);
            border: 2px solid #fff;
        }

        #scope-crosshair-h {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: #ff0000;
        }
        #scope-crosshair-v {
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            background-color: #ff0000;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            z-index: 101;
        }

        #health-bar {
            width: 200px;
            height: 20px;
            background-color: #555;
            border: 2px solid #ccc;
            border-radius: 5px;
            margin-top: 5px;
        }

        #health-bar-fill {
            height: 100%;
            width: 100%;
            background-color: #4CAF50;
            border-radius: 3px;
            transition: width 0.3s ease-in-out;
        }

        #game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 200;
        }

        #controls-message {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
            color: #eee;
            z-index: 150;
        }

        #scoreboard {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            z-index: 101;
            text-align: center;
        }

        #timer {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="crosshair"></div>
    <!-- New HTML for the sniper scope -->
    <div id="sniper-scope">
        <div id="scope-overlay">
            <div id="scope-crosshair-h"></div>
            <div id="scope-crosshair-v"></div>
        </div>
    </div>
    <div id="hud">
        Zdravie: <br>
        <div id="health-bar"><div id="health-bar-fill"></div></div>
        <br>
        Zbraň: <span id="current-weapon">Pištoľ</span>
    </div>
    <div id="scoreboard">
        <div id="timer">Čas: 10:00</div>
        <div id="score">
            <span id="blue-score">0</span> - <span id="red-score">0</span>
        </div>
    </div>
    <div id="game-message"></div>
    <div id="controls-message">
        Klikni pre štart. Pohyb: WASD alebo šípky. Strieľaj: ľavé tlačidlo myši. Zameraj sa: pravé tlačidlo myši. Zbraň: koliesko myši alebo 1-0.
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
<script>
    // Global variables for the game state
    let scene, camera, renderer, controls;
    let playerHealth = 100;
    let isGameOver = false;
    let hasGameStarted = false; // Flag to show the start message only once
    let weaponModel;

    // Define weapons as an array of objects for better management
    const weapons = [
        { name: "Pištoľ", damage: 100, fireRate: 200, zoom: 75, speedMultiplier: 1.0 },
        { name: "Útočná puška", damage: 30, fireRate: 80, zoom: 75, speedMultiplier: 1.0 },
        { name: "Snajperka", damage: 2000, fireRate: 1500, zoom: 20, speedMultiplier: 0.5 },
        { name: "Brokovnica", damage: 250, fireRate: 500, zoom: 75, speedMultiplier: 1.0 },
        { name: "Guľomet", damage: 15, fireRate: 50, zoom: 75, speedMultiplier: 0.8 },
        { name: "Raketomet", damage: 5000, fireRate: 3000, zoom: 75, speedMultiplier: 0.6 },
        { name: "SMG", damage: 20, fireRate: 60, zoom: 75, speedMultiplier: 1.1 },
        { name: "Lúčová puška", damage: 150, fireRate: 100, zoom: 75, speedMultiplier: 1.0 },
        { name: "Plazmová pištoľ", damage: 120, fireRate: 150, zoom: 75, speedMultiplier: 1.0 },
        { name: "Granátomet", damage: 1000, fireRate: 2000, zoom: 75, speedMultiplier: 0.7 }
    ];
    let currentWeaponIndex = 0;
    let enemies = [];
    let friendlyAI = []; // New array for friendly AI
    let bullets = []; 
    let enemyBullets = []; 
    let friendlyBullets = []; // New array for friendly AI bullets
    let lastShotTime = 0;
    
    // Movement variables
    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let canJump = true;
    let velocity = new THREE.Vector3();
    const speed = 150.0;
    const playerHeight = 50;
    
    // AI Spawning
    const maxUnitsPerTeam = 40; // Max number of units per team on the map at once

    // New variables for scoring and time
    let blueScore = 0;
    let redScore = 0;
    let gameTimeLeft = 600; // 10 minutes in seconds

    // New variables for scoping
    let isScoped = false;
    const defaultFOV = 75;

    // Game elements
    const hud = document.getElementById('hud');
    const healthBarFill = document.getElementById('health-bar-fill');
    const currentWeaponDisplay = document.getElementById('current-weapon');
    const gameMessage = document.getElementById('game-message');
    const controlsMessage = document.getElementById('controls-message');
    const crosshair = document.getElementById('crosshair');
    const sniperScope = document.getElementById('sniper-scope');
    const scoreboard = document.getElementById('scoreboard');
    const timerDisplay = document.getElementById('timer');
    const blueScoreDisplay = document.getElementById('blue-score');
    const redScoreDisplay = document.getElementById('red-score');

    // Store all the physical objects for AI collision detection
    const obstacles = [];

    // Message Box function
    function showMessage(message, duration = 2000) {
        gameMessage.textContent = message;
        gameMessage.style.display = 'block';
        setTimeout(() => {
            gameMessage.style.display = 'none';
        }, duration);
    }

    // Function to create a simple weapon model
    function createWeaponModel() {
        const weaponGeometry = new THREE.BoxGeometry(5, 5, 25);
        const weaponMaterial = new THREE.MeshLambertMaterial({ color: 0x505050 });
        weaponModel = new THREE.Mesh(weaponGeometry, weaponMaterial);
        
        // Position the weapon relative to the camera
        weaponModel.position.set(15, -10, -25);
        weaponModel.rotation.y = Math.PI * 0.2;
        
        // Add a barrel for visual effect
        const barrelGeometry = new THREE.BoxGeometry(2, 2, 15);
        const barrelMaterial = new THREE.MeshLambertMaterial({ color: 0x303030 });
        const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
        barrel.position.z = -20;
        weaponModel.add(barrel);
        
        // Add the weapon model as a child of the camera
        camera.add(weaponModel);
    }

    // Initialize the game
    function init() {
        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue background
        scene.fog = new THREE.Fog(0x87ceeb, 0, 750);

        // Camera
        camera = new THREE.PerspectiveCamera(defaultFOV, window.innerWidth / window.innerHeight, 1, 1000);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('game-container').appendChild(renderer.domElement);

        // Create and add the weapon model to the camera
        createWeaponModel();

        // Controls
        const gameContainer = document.getElementById('game-container');
        controls = new THREE.PointerLockControls(camera, gameContainer);
        
        // Use a simple click event to lock the pointer
        gameContainer.addEventListener('click', () => {
            controls.lock();
        });

        controls.addEventListener('lock', () => {
            hud.style.display = 'block';
            crosshair.style.display = 'block';
            controlsMessage.style.display = 'none';
            scoreboard.style.display = 'block';
            if (!hasGameStarted) {
                 showMessage("Hra sa začína!");
                 hasGameStarted = true;
            }
            isGameOver = false;
        });

        controls.addEventListener('unlock', () => {
            if (!isGameOver) {
                hud.style.display = 'none';
                crosshair.style.display = 'none';
                controlsMessage.style.display = 'block';
                scoreboard.style.display = 'none';
            }
        });

        // Add event listeners for movement
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);
        document.addEventListener('mousedown', onMouseDown, false);
        document.addEventListener('contextmenu', onRightClick, false); // Add right-click listener
        document.addEventListener('wheel', onMouseWheel, false); // Add mouse wheel listener

        // Raycaster for shooting and AI
        raycaster = new THREE.Raycaster();

        // Create the game world
        createWorld();

        // Spawn initial units for both teams
        for (let i = 0; i < maxUnitsPerTeam; i++) {
            spawnUnit('red');
            spawnUnit('blue');
        }

        // Start the animation loop
        animate();
    }
    
    // Function to handle weapon switching with mouse wheel
    function onMouseWheel(event) {
        if (controls.isLocked === true && !isGameOver) {
            // Check scroll direction
            if (event.deltaY > 0) { // Scrolling down
                currentWeaponIndex++;
            } else { // Scrolling up
                currentWeaponIndex--;
            }

            // Wrap the index to stay within the bounds of the weapons array
            currentWeaponIndex = (currentWeaponIndex + weapons.length) % weapons.length;

            // Update the weapon display and scope state
            updateWeapon();
        }
    }

    // Function to update weapon display and scope
    function updateWeapon() {
        currentWeaponDisplay.textContent = weapons[currentWeaponIndex].name;
        // Turn off scope when switching weapons
        isScoped = false;
        crosshair.style.display = 'block';
        sniperScope.style.display = 'none';
        camera.fov = defaultFOV;
        camera.updateProjectionMatrix();
        weaponModel.visible = true; // Make sure the weapon is visible
    }

    // Function to create a colorful and simple world
    function createWorld() {
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x8a795d }); // Earthy brown
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);
        obstacles.push(ground);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 100, 100);
        scene.add(directionalLight);

        // Create houses and obstacles
        const houseColors = [0xff4d4d, 0x4dff4d, 0x4d4dff, 0xffff4d, 0xff4dff];
        for (let i = 0; i < 20; i++) {
            const width = Math.random() * 50 + 20;
            const depth = Math.random() * 50 + 20;
            const height = Math.random() * 50 + 20;
            const houseGeometry = new THREE.BoxGeometry(width, height, depth);
            const houseMaterial = new THREE.MeshLambertMaterial({ color: houseColors[Math.floor(Math.random() * houseColors.length)] });
            const house = new THREE.Mesh(houseGeometry, houseMaterial);
            house.position.x = Math.random() * 1800 - 900;
            house.position.z = Math.random() * 1800 - 900;
            house.position.y = height / 2;
            scene.add(house);
            obstacles.push(house);
        }

        // --- Boundaries/Walls ---
        const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
        const wallHeight = 100;
        const wallDepth = 20;
        const wallWidth = 2000 + wallDepth; // To ensure no gaps

        // North Wall
        const northWall = new THREE.Mesh(new THREE.BoxGeometry(wallWidth, wallHeight, wallDepth), wallMaterial);
        northWall.position.set(0, wallHeight / 2, -1000 - wallDepth / 2);
        scene.add(northWall);
        obstacles.push(northWall);

        // South Wall
        const southWall = new THREE.Mesh(new THREE.BoxGeometry(wallWidth, wallHeight, wallDepth), wallMaterial);
        southWall.position.set(0, wallHeight / 2, 1000 + wallDepth / 2);
        scene.add(southWall);
        obstacles.push(southWall);

        // West Wall
        const westWall = new THREE.Mesh(new THREE.BoxGeometry(wallDepth, wallHeight, wallWidth), wallMaterial);
        westWall.position.set(-1000 - wallDepth / 2, wallHeight / 2, 0);
        scene.add(westWall);
        obstacles.push(westWall);

        // East Wall
        const eastWall = new THREE.Mesh(new THREE.BoxGeometry(wallDepth, wallHeight, wallWidth), wallMaterial);
        eastWall.position.set(1000 + wallDepth / 2, wallHeight / 2, 0);
        scene.add(eastWall);
        obstacles.push(eastWall);
    }

    // Function to spawn AI units (red enemies or blue friendlies)
    function spawnUnit(team) {
        const safeZoneRadius = 200; // Define a radius around the player spawn point to avoid
        const spawnRange = 900; // Max spawn distance from center

        const materialColor = (team === 'red') ? 0xff0000 : 0x0000ff;
        const unitGeometry = new THREE.BoxGeometry(20, 40, 20);
        const unitMaterial = new THREE.MeshLambertMaterial({ color: materialColor });
        const unit = new THREE.Mesh(unitGeometry, unitMaterial);
        
        let x, z;
        do {
            x = Math.random() * spawnRange * 2 - spawnRange;
            z = Math.random() * spawnRange * 2 - spawnRange;
        } while (Math.sqrt(x * x + z * z) < safeZoneRadius);

        unit.position.x = x;
        unit.position.z = z;
        unit.position.y = 20;
        unit.health = 100;
        unit.lastShotTime = 0;

        if (team === 'red') {
            enemies.push(unit);
        } else {
            friendlyAI.push(unit);
        }
        scene.add(unit);
    }

    // Player shooting logic without fire rate limit
    function onMouseDown(event) {
        if (controls.isLocked === true && event.button === 0 && !isGameOver) {
            // No fire rate check, so you can shoot as fast as you click
            const currentWeapon = weapons[currentWeaponIndex];
            
            // Create a bullet mesh for the player
            const bulletGeometry = new THREE.SphereGeometry(2, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Yellow bullet for the player
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

            // Position the bullet at the camera's location
            bullet.position.copy(camera.position);

            // Set bullet velocity
            const bulletDirection = new THREE.Vector3();
            camera.getWorldDirection(bulletDirection);
            bullet.velocity = bulletDirection.multiplyScalar(1000); // Set bullet speed

            scene.add(bullet);
            bullets.push(bullet);
        }
    }
    
    // Right-click to toggle scope
    function onRightClick(event) {
        if (controls.isLocked === true && !isGameOver) {
            event.preventDefault(); // Prevent context menu from appearing
            
            const currentWeapon = weapons[currentWeaponIndex];
            if (currentWeapon.name === "Snajperka") {
                isScoped = !isScoped;
                crosshair.style.display = isScoped ? 'none' : 'block';
                sniperScope.style.display = isScoped ? 'block' : 'none';
                weaponModel.visible = !isScoped; // Hide the weapon when scoped
            } else {
                 isScoped = false;
                 crosshair.style.display = 'block';
                 sniperScope.style.display = 'none';
                 weaponModel.visible = true; // Ensure weapon is visible for other guns
            }
            // Change camera FOV
            camera.fov = isScoped ? currentWeapon.zoom : defaultFOV;
            camera.updateProjectionMatrix();
        }
    }

    // Find the nearest target (enemy for friendly AI, friendly AI or player for enemies)
    function findNearestTarget(unit, targets) {
        let nearestTarget = null;
        let minDistance = Infinity;

        // Combine friendly AI and player as targets for red enemies
        if (unit.material.color.getHex() === 0xff0000) {
            const playerPosition = controls.getObject().position;
            targets = [...friendlyAI, { position: playerPosition, isPlayer: true }];
        }
        
        targets.forEach(target => {
            const distance = unit.position.distanceTo(target.position);
            if (distance < minDistance) {
                minDistance = distance;
                nearestTarget = target;
            }
        });
        return nearestTarget;
    }

    // Function to check for and avoid obstacles
    function avoidObstacles(unit, direction) {
        const avoidanceRaycaster = new THREE.Raycaster(unit.position, direction, 0, 50);
        const intersections = avoidanceRaycaster.intersectObjects(obstacles, true);
        if (intersections.length > 0) {
            // Found an obstacle, change direction randomly
            direction.set(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
        }
    }

    // AI logic for enemies (red) and friendly AI (blue)
    function updateAI(delta) {
        const separationDistance = 100; // Distance to maintain from other units
        const avoidanceStrength = 0.5; // How much to prioritize avoidance over targeting

        // Logic for red enemies
        enemies.forEach(enemy => {
            // Find nearest target
            const target = findNearestTarget(enemy, friendlyAI);
            let targetDirection = new THREE.Vector3();
            if (target) {
                targetDirection.subVectors(target.position, enemy.position);
            }

            // Calculate avoidance vector from other enemies
            let avoidanceVector = new THREE.Vector3();
            enemies.forEach(otherEnemy => {
                if (enemy !== otherEnemy) {
                    const distance = enemy.position.distanceTo(otherEnemy.position);
                    if (distance < separationDistance) {
                        const awayVector = new THREE.Vector3().subVectors(enemy.position, otherEnemy.position);
                        awayVector.normalize();
                        avoidanceVector.add(awayVector);
                    }
                }
            });

            // Combine the vectors
            let combinedVector = new THREE.Vector3();
            combinedVector.addScaledVector(targetDirection.normalize(), 1.0); // Prioritize targeting
            combinedVector.addScaledVector(avoidanceVector, avoidanceStrength); // Add avoidance
            
            // Check for and avoid obstacles before moving
            avoidObstacles(enemy, combinedVector);
            
            // Move the enemy
            if (combinedVector.length() > 0) {
                combinedVector.normalize();
                enemy.position.addScaledVector(combinedVector, delta * 80);
            }
            enemy.position.y = 20; // Keep the NPC on the ground!

            // The AI is now more aggressive and shoots more often
            const currentTime = performance.now();
            if (target && currentTime - enemy.lastShotTime > 500) { // Increased fire rate
                enemy.lastShotTime = currentTime;
                
                const enemyBulletGeometry = new THREE.SphereGeometry(2, 8, 8);
                const enemyBulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const enemyBullet = new THREE.Mesh(enemyBulletGeometry, enemyBulletMaterial);
                enemyBullet.position.copy(enemy.position);
                enemyBullet.position.y += 20;

                const enemyBulletDirection = new THREE.Vector3().subVectors(target.position, enemy.position);
                enemyBulletDirection.normalize();
                enemyBullet.velocity = enemyBulletDirection.multiplyScalar(500);

                scene.add(enemyBullet);
                enemyBullets.push(enemyBullet);
            }
        });

        // Logic for friendly AI
        friendlyAI.forEach(friendly => {
            // Find nearest target
            const target = findNearestTarget(friendly, enemies);
            let targetDirection = new THREE.Vector3();
            if (target) {
                targetDirection.subVectors(target.position, friendly.position);
            }

            // Calculate avoidance vector from other friendly AI
            let avoidanceVector = new THREE.Vector3();
            friendlyAI.forEach(otherFriendly => {
                if (friendly !== otherFriendly) {
                    const distance = friendly.position.distanceTo(otherFriendly.position);
                    if (distance < separationDistance) {
                        const awayVector = new THREE.Vector3().subVectors(friendly.position, otherFriendly.position);
                        awayVector.normalize();
                        avoidanceVector.add(awayVector);
                    }
                }
            });

            // Combine the vectors
            let combinedVector = new THREE.Vector3();
            combinedVector.addScaledVector(targetDirection.normalize(), 1.0);
            combinedVector.addScaledVector(avoidanceVector, avoidanceStrength);
            
            // Check for and avoid obstacles before moving
            avoidObstacles(friendly, combinedVector);

            // Move the friendly AI
            if (combinedVector.length() > 0) {
                combinedVector.normalize();
                friendly.position.addScaledVector(combinedVector, delta * 80);
            }
            friendly.position.y = 20; // Keep the NPC on the ground!
            
            // The AI is now more aggressive and shoots more often
            const currentTime = performance.now();
            if (target && currentTime - friendly.lastShotTime > 500) { // Increased fire rate
                friendly.lastShotTime = currentTime;

                const friendlyBulletGeometry = new THREE.SphereGeometry(2, 8, 8);
                const friendlyBulletMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff }); // Cyan bullets for friendly AI
                const friendlyBullet = new THREE.Mesh(friendlyBulletGeometry, friendlyBulletMaterial);
                friendlyBullet.position.copy(friendly.position);
                friendlyBullet.position.y += 20;

                const friendlyBulletDirection = new THREE.Vector3().subVectors(target.position, friendly.position);
                friendlyBulletDirection.normalize();
                friendlyBullet.velocity = friendlyBulletDirection.multiplyScalar(500);

                scene.add(friendlyBullet);
                friendlyBullets.push(friendlyBullet);
            }
        });
    }

    // Function to handle the death of an AI unit
    function handleAIDeath(unit, team) {
        scene.remove(unit);
        if (team === 'red') {
            const index = enemies.indexOf(unit);
            if (index > -1) {
                enemies.splice(index, 1);
            }
        } else {
            const index = friendlyAI.indexOf(unit);
            if (index > -1) {
                friendlyAI.splice(index, 1);
            }
        }
        
        // Immediately respawn a new unit of the same team
        spawnUnit(team);
    }


    // Update bullets and check for collisions
    function updateBullets(delta) {
        // Player's bullets hitting enemies
        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            bullet.position.addScaledVector(bullet.velocity, delta);

            let hit = false;
            for (let j = enemies.length - 1; j >= 0; j--) {
                const enemy = enemies[j];
                const distance = bullet.position.distanceTo(enemy.position);

                if (distance < 20) {
                    enemy.health -= weapons[currentWeaponIndex].damage; 
                    if (enemy.health <= 0) {
                        handleAIDeath(enemy, 'red'); // Call the death function
                        blueScore++; // Player is on the blue team
                    }
                    hit = true;
                    break;
                }
            }

            if (hit || bullet.position.length() > 1000) {
                scene.remove(bullet);
                bullets.splice(i, 1);
            }
        }
    }

    // Update enemy bullets and check for collision with player or friendly AI
    function updateEnemyBullets(delta) {
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
            const bullet = enemyBullets[i];
            bullet.position.addScaledVector(bullet.velocity, delta);
            
            const playerPosition = controls.getObject().position;
            const distanceToPlayer = bullet.position.distanceTo(playerPosition);
            let hit = false;
            
            if (distanceToPlayer < 20) { // Collision with player
                takeDamage(10);
                hit = true;
            } else { // Check for collision with friendly AI
                for (let j = friendlyAI.length - 1; j >= 0; j--) {
                    const friendly = friendlyAI[j];
                    const distanceToFriendly = bullet.position.distanceTo(friendly.position);
                    if (distanceToFriendly < 20) {
                        friendly.health -= 10;
                        if (friendly.health <= 0) {
                            handleAIDeath(friendly, 'blue'); // Call the death function
                            redScore++;
                        }
                        hit = true;
                        break;
                    }
                }
            }

            if (hit || bullet.position.length() > 1000) {
                scene.remove(bullet);
                enemyBullets.splice(i, 1);
            }
        }
    }

    // Update friendly bullets and check for collision with enemies
    function updateFriendlyBullets(delta) {
        for (let i = friendlyBullets.length - 1; i >= 0; i--) {
            const bullet = friendlyBullets[i];
            bullet.position.addScaledVector(bullet.velocity, delta);

            let hit = false;
            for (let j = enemies.length - 1; j >= 0; j--) {
                const enemy = enemies[j];
                const distance = bullet.position.distanceTo(enemy.position);

                if (distance < 20) {
                    enemy.health -= 20; // Friendly AI damage
                    if (enemy.health <= 0) {
                        handleAIDeath(enemy, 'red'); // Call the death function
                        blueScore++; // Friendly AI kill
                    }
                    hit = true;
                    break;
                }
            }

            if (hit || bullet.position.length() > 1000) {
                scene.remove(bullet);
                friendlyBullets.splice(i, 1);
            }
        }
    }

    // Player damage logic
    function takeDamage(amount) {
        playerHealth -= amount;
        if (playerHealth < 0) playerHealth = 0;
        healthBarFill.style.width = `${playerHealth}%`;
        if (playerHealth <= 0) {
            redScore++; // Zvýšenie skóre červeného tímu, keď ťa zabijú
            gameOver();
        }
    }

    // Game over logic (from player death)
    function gameOver() {
        isGameOver = true;
        controls.unlock();
        showMessage("Zomrel si! Znovuzrodenie...", 3000);
            
        setTimeout(() => {
            playerHealth = 100;
            healthBarFill.style.width = `${playerHealth}%`;
            controls.getObject().position.set(0, playerHeight, 0);
            enemyBullets.forEach(bullet => scene.remove(bullet));
            enemyBullets = [];
            isGameOver = false;
            controls.lock();
        }, 3000);
    }
    
    // Game over logic (from timer)
    function endGame() {
        isGameOver = true;
        controls.unlock();
        let message = "";
        if (blueScore > redScore) {
            message = "Modrý tím vyhral!";
        } else if (redScore > blueScore) {
            message = "Červený tím vyhral!";
        } else {
            message = "Remíza!";
        }
        showMessage(`Hra skončila! ${message}`, 5000);

        // Reset game state after a delay for a new arena
        setTimeout(resetGame, 5000);
    }

    function resetGame() {
        // Clear all enemies and friendly AI from the scene and arrays
        enemies.forEach(enemy => scene.remove(enemy));
        enemies = [];
        friendlyAI.forEach(friendly => scene.remove(friendly));
        friendlyAI = [];
        bullets.forEach(bullet => scene.remove(bullet));
        bullets = [];
        enemyBullets.forEach(bullet => scene.remove(bullet));
        enemyBullets = [];
        friendlyBullets.forEach(bullet => scene.remove(bullet));
        friendlyBullets = [];
        
        // Reset scores and timer
        blueScore = 0;
        redScore = 0;
        gameTimeLeft = 600;
        playerHealth = 100;
        healthBarFill.style.width = `${playerHealth}%`;
        
        // Respawn initial units
        for (let i = 0; i < maxUnitsPerTeam; i++) {
            spawnUnit('red');
            spawnUnit('blue');
        }

        // Respawn player
        controls.getObject().position.set(0, playerHeight, 0);

        // Start the game again
        isGameOver = false;
        controls.lock();
    }

    // Update scoreboard GUI
    function updateScoreboard() {
        const minutes = Math.floor(gameTimeLeft / 60);
        const seconds = Math.floor(gameTimeLeft % 60).toString().padStart(2, '0');
        timerDisplay.textContent = `Čas: ${minutes}:${seconds}`;
        blueScoreDisplay.textContent = blueScore;
        redScoreDisplay.textContent = redScore;
    }

    // Keyboard input handling
    function onKeyDown(event) {
        switch (event.code) {
            case 'KeyW':
            case 'ArrowUp':
                moveForward = true;
                break;
            case 'KeyA':
            case 'ArrowLeft':
                moveLeft = true;
                break;
            case 'KeyS':
            case 'ArrowDown':
                moveBackward = true;
                break;
            case 'KeyD':
            case 'ArrowRight':
                moveRight = true;
                break;
            case 'Space':
                if (canJump === true) velocity.y += 350;
                canJump = false;
                break;
            default:
                if (event.code.startsWith('Digit')) {
                    const digit = parseInt(event.code.slice(5), 10);
                    if (digit >= 1 && digit <= weapons.length) {
                        currentWeaponIndex = digit - 1;
                        updateWeapon();
                    }
                }
                break;
        }
    }

    function onKeyUp(event) {
        switch (event.code) {
            case 'KeyW':
            case 'ArrowUp':
                moveForward = false;
                break;
            case 'KeyA':
            case 'ArrowLeft':
                moveLeft = false;
                break;
            case 'KeyS':
            case 'ArrowDown':
                moveBackward = false;
                break;
            case 'KeyD':
            case 'ArrowRight':
                moveRight = false;
                break;
        }
    }

    // Animation loop
    let prevTime = performance.now();
    function animate() {
        requestAnimationFrame(animate);

        const currentTime = performance.now();
        const delta = (currentTime - prevTime) / 1000;

        if (controls.isLocked === true && !isGameOver) {
            // Update game timer
            gameTimeLeft -= delta;
            if (gameTimeLeft <= 0) {
                gameTimeLeft = 0;
                endGame();
            }
            updateScoreboard();

            // Apply gravity
            velocity.y -= 9.8 * 100.0 * delta;

            const currentWeapon = weapons[currentWeaponIndex];
            const currentSpeed = speed * currentWeapon.speedMultiplier;

            const horizontalVelocity = new THREE.Vector3();
            if (moveForward) horizontalVelocity.z += currentSpeed;
            if (moveBackward) horizontalVelocity.z -= currentSpeed;
            if (moveLeft) horizontalVelocity.x -= currentSpeed;
            if (moveRight) horizontalVelocity.x += currentSpeed;

            controls.moveRight(horizontalVelocity.x * delta);
            controls.moveForward(horizontalVelocity.z * delta);

            controls.getObject().position.y += velocity.y * delta;

            if (controls.getObject().position.y < playerHeight) {
                velocity.y = 0;
                controls.getObject().position.y = playerHeight;
                canJump = true;
            }

            // --- Collision detection with the outer walls ---
            const playerPosition = controls.getObject().position;
            const wallBoundary = 980; // A little buffer to avoid issues
            
            // Clamp the player's position to stay within the boundaries
            playerPosition.x = Math.max(-wallBoundary, Math.min(wallBoundary, playerPosition.x));
            playerPosition.z = Math.max(-wallBoundary, Math.min(wallBoundary, playerPosition.z));

            // Update AI and bullets
            updateAI(delta);
            updateBullets(delta); 
            updateEnemyBullets(delta); 
            updateFriendlyBullets(delta);
        }

        prevTime = currentTime;
        renderer.render(scene, camera);
    }

    // Start the game when the window loads
    window.onload = init;
</script>

</body>
</html>

