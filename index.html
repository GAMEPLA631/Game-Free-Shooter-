<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roblox Shooting Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            color: #fff;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-left: -10px;
            margin-top: -10px;
            border: 2px solid white;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 5px 2px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 100;
        }

        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background-color: white;
            border-radius: 50%;
        }

        #sniper-scope {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none; /* Initially hidden */
            z-index: 101;
            pointer-events: none;
        }

        #scope-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vh;
            height: 100vh;
            border-radius: 50%;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.8);
            border: 2px solid #fff;
        }

        #scope-crosshair-h {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: #ff0000;
        }
        #scope-crosshair-v {
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            background-color: #ff0000;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            z-index: 101;
        }

        #health-bar {
            width: 200px;
            height: 20px;
            background-color: #555;
            border: 2px solid #ccc;
            border-radius: 5px;
            margin-top: 5px;
        }

        #health-bar-fill {
            height: 100%;
            width: 100%;
            background-color: #4CAF50;
            border-radius: 3px;
            transition: width 0.3s ease-in-out;
        }

        #game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 200;
        }

        #controls-message {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
            color: #eee;
            z-index: 150;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="crosshair"></div>
    <!-- New HTML for the sniper scope -->
    <div id="sniper-scope">
        <div id="scope-overlay">
            <div id="scope-crosshair-h"></div>
            <div id="scope-crosshair-v"></div>
        </div>
    </div>
    <div id="hud">
        Zdravie: <br>
        <div id="health-bar"><div id="health-bar-fill"></div></div>
        <br>
        Zbraň: <span id="current-weapon">Pištoľ</span>
    </div>
    <div id="game-message"></div>
    <div id="controls-message">
        Klikni pre štart. Pohyb: WASD alebo šípky. Strieľaj: ľavé tlačidlo myši. Zameraj sa: pravé tlačidlo myši. Zbraň: koliesko myši alebo 1-0.
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
<script>
    // Global variables for the game state
    let scene, camera, renderer, controls;
    let playerHealth = 100;
    let isGameOver = false;
    let hasGameStarted = false; // Flag to show the start message only once
    let weaponModel;

    // Define weapons as an array of objects for better management
    const weapons = [
        { name: "Pištoľ", damage: 100, fireRate: 200, zoom: 75, speedMultiplier: 1.0 },
        { name: "Útočná puška", damage: 30, fireRate: 80, zoom: 75, speedMultiplier: 1.0 },
        { name: "Snajperka", damage: 2000, fireRate: 1500, zoom: 20, speedMultiplier: 0.5 },
        { name: "Brokovnica", damage: 250, fireRate: 500, zoom: 75, speedMultiplier: 1.0 },
        { name: "Guľomet", damage: 15, fireRate: 50, zoom: 75, speedMultiplier: 0.8 },
        { name: "Raketomet", damage: 5000, fireRate: 3000, zoom: 75, speedMultiplier: 0.6 },
        { name: "SMG", damage: 20, fireRate: 60, zoom: 75, speedMultiplier: 1.1 },
        { name: "Lúčová puška", damage: 150, fireRate: 100, zoom: 75, speedMultiplier: 1.0 },
        { name: "Plazmová pištoľ", damage: 120, fireRate: 150, zoom: 75, speedMultiplier: 1.0 },
        { name: "Granátomet", damage: 1000, fireRate: 2000, zoom: 75, speedMultiplier: 0.7 }
    ];
    let currentWeaponIndex = 0;
    let enemies = [];
    let bullets = []; 
    let enemyBullets = []; 
    let lastShotTime = 0;
    
    // Movement variables
    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let canJump = true;
    let velocity = new THREE.Vector3();
    const speed = 150.0;
    const playerHeight = 50;
    
    // Enemy spawning
    let lastEnemySpawn = 0;
    const enemySpawnInterval = 1000; // spawn every 1 second
    const maxEnemies = 20; // Max number of enemies on the map at once

    // New variables for scoping
    let isScoped = false;
    const defaultFOV = 75;

    // Game elements
    const hud = document.getElementById('hud');
    const healthBarFill = document.getElementById('health-bar-fill');
    const currentWeaponDisplay = document.getElementById('current-weapon');
    const gameMessage = document.getElementById('game-message');
    const controlsMessage = document.getElementById('controls-message');
    const crosshair = document.getElementById('crosshair');
    const sniperScope = document.getElementById('sniper-scope');

    // Message Box function
    function showMessage(message, duration = 2000) {
        gameMessage.textContent = message;
        gameMessage.style.display = 'block';
        setTimeout(() => {
            gameMessage.style.display = 'none';
        }, duration);
    }

    // Function to create a simple weapon model
    function createWeaponModel() {
        const weaponGeometry = new THREE.BoxGeometry(5, 5, 25);
        const weaponMaterial = new THREE.MeshLambertMaterial({ color: 0x505050 });
        weaponModel = new THREE.Mesh(weaponGeometry, weaponMaterial);
        
        // Position the weapon relative to the camera
        weaponModel.position.set(15, -10, -25);
        weaponModel.rotation.y = Math.PI * 0.2;
        
        // Add a barrel for visual effect
        const barrelGeometry = new THREE.BoxGeometry(2, 2, 15);
        const barrelMaterial = new THREE.MeshLambertMaterial({ color: 0x303030 });
        const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
        barrel.position.z = -20;
        weaponModel.add(barrel);
        
        // Add the weapon model as a child of the camera
        camera.add(weaponModel);
    }

    // Initialize the game
    function init() {
        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue background
        scene.fog = new THREE.Fog(0x87ceeb, 0, 750);

        // Camera
        camera = new THREE.PerspectiveCamera(defaultFOV, window.innerWidth / window.innerHeight, 1, 1000);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('game-container').appendChild(renderer.domElement);

        // Create and add the weapon model to the camera
        createWeaponModel();

        // Controls
        const gameContainer = document.getElementById('game-container');
        controls = new THREE.PointerLockControls(camera, gameContainer);
        
        // Use a simple click event to lock the pointer
        gameContainer.addEventListener('click', () => {
            controls.lock();
        });

        controls.addEventListener('lock', () => {
            hud.style.display = 'block';
            crosshair.style.display = 'block';
            controlsMessage.style.display = 'none';
            if (!hasGameStarted) {
                 showMessage("Hra sa začína!");
                 hasGameStarted = true;
            }
            isGameOver = false;
        });

        controls.addEventListener('unlock', () => {
            if (!isGameOver) {
                hud.style.display = 'none';
                crosshair.style.display = 'none';
                controlsMessage.style.display = 'block';
            }
        });

        // Add event listeners for movement
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);
        document.addEventListener('mousedown', onMouseDown, false);
        document.addEventListener('contextmenu', onRightClick, false); // Add right-click listener
        document.addEventListener('wheel', onMouseWheel, false); // Add mouse wheel listener

        // Raycaster for shooting
        raycaster = new THREE.Raycaster();

        // Create the game world
        createWorld();

        // Start the animation loop
        animate();
    }
    
    // Function to handle weapon switching with mouse wheel
    function onMouseWheel(event) {
        if (controls.isLocked === true && !isGameOver) {
            // Check scroll direction
            if (event.deltaY > 0) { // Scrolling down
                currentWeaponIndex++;
            } else { // Scrolling up
                currentWeaponIndex--;
            }

            // Wrap the index to stay within the bounds of the weapons array
            currentWeaponIndex = (currentWeaponIndex + weapons.length) % weapons.length;

            // Update the weapon display and scope state
            updateWeapon();
        }
    }

    // Function to update weapon display and scope
    function updateWeapon() {
        currentWeaponDisplay.textContent = weapons[currentWeaponIndex].name;
        // Turn off scope when switching weapons
        isScoped = false;
        crosshair.style.display = 'block';
        sniperScope.style.display = 'none';
        camera.fov = defaultFOV;
        camera.updateProjectionMatrix();
        weaponModel.visible = true; // Make sure the weapon is visible
    }

    // Function to create a colorful and simple world
    function createWorld() {
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x8a795d }); // Earthy brown
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 100, 100);
        scene.add(directionalLight);

        // Create houses and obstacles
        const houseColors = [0xff4d4d, 0x4dff4d, 0x4d4dff, 0xffff4d, 0xff4dff];
        for (let i = 0; i < 20; i++) {
            const width = Math.random() * 50 + 20;
            const depth = Math.random() * 50 + 20;
            const height = Math.random() * 50 + 20;
            const houseGeometry = new THREE.BoxGeometry(width, height, depth);
            const houseMaterial = new THREE.MeshLambertMaterial({ color: houseColors[Math.floor(Math.random() * houseColors.length)] });
            const house = new THREE.Mesh(houseGeometry, houseMaterial);
            house.position.x = Math.random() * 1800 - 900;
            house.position.z = Math.random() * 1800 - 900;
            house.position.y = height / 2;
            scene.add(house);
        }
    }

    // Function to spawn AI enemies
    function spawnEnemies() {
        if (enemies.length >= maxEnemies) {
            return;
        }

        const safeZoneRadius = 200; // Define a radius around the player spawn point to avoid
        const spawnRange = 900; // Max spawn distance from center

        const enemyGeometry = new THREE.BoxGeometry(20, 40, 20);
        const enemyMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
        const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
        
        let x, z;
        // Generate coordinates outside the safe zone around the player's spawn point (0,0,0)
        do {
            x = Math.random() * spawnRange * 2 - spawnRange; // -900 to 900
            z = Math.random() * spawnRange * 2 - spawnRange; // -900 to 900
        } while (Math.sqrt(x * x + z * z) < safeZoneRadius);

        enemy.position.x = x;
        enemy.position.z = z;
        enemy.position.y = 20;
        enemy.health = 100;
        enemy.lastShotTime = 0;
        enemies.push(enemy);
        scene.add(enemy);
    }

    // Player shooting logic
    function onMouseDown(event) {
        if (controls.isLocked === true && event.button === 0 && !isGameOver) {
            const currentTime = performance.now();
            const currentWeapon = weapons[currentWeaponIndex];
            if (currentTime - lastShotTime > currentWeapon.fireRate) {
                lastShotTime = currentTime;

                // Create a bullet mesh
                const bulletGeometry = new THREE.SphereGeometry(2, 8, 8);
                const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Yellow bullet for the player
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

                // Position the bullet at the camera's location
                bullet.position.copy(camera.position);

                // Set bullet velocity
                const bulletDirection = new THREE.Vector3();
                camera.getWorldDirection(bulletDirection);
                bullet.velocity = bulletDirection.multiplyScalar(1000); // Set bullet speed

                scene.add(bullet);
                bullets.push(bullet);
            }
        }
    }
    
    // Right-click to toggle scope
    function onRightClick(event) {
        if (controls.isLocked === true && !isGameOver) {
            event.preventDefault(); // Prevent context menu from appearing
            
            const currentWeapon = weapons[currentWeaponIndex];
            if (currentWeapon.name === "Snajperka") {
                isScoped = !isScoped;
                crosshair.style.display = isScoped ? 'none' : 'block';
                sniperScope.style.display = isScoped ? 'block' : 'none';
                weaponModel.visible = !isScoped; // Hide the weapon when scoped
            } else {
                 isScoped = false;
                 crosshair.style.display = 'block';
                 sniperScope.style.display = 'none';
                 weaponModel.visible = true; // Ensure weapon is visible for other guns
            }
            // Change camera FOV
            camera.fov = isScoped ? currentWeapon.zoom : defaultFOV;
            camera.updateProjectionMatrix();
        }
    }

    // AI logic for enemies
    function updateEnemies(delta) {
        const playerPosition = controls.getObject().position;
        enemies.forEach(enemy => {
            // Simple AI: Move towards the player
            const directionVector = new THREE.Vector3().subVectors(playerPosition, enemy.position);
            directionVector.y = 0; // Keep movement on the horizontal plane
            directionVector.normalize();
            enemy.position.addScaledVector(directionVector, delta * 80);

            // Simple AI: Shoot at the player
            const currentTime = performance.now();
            if (currentTime - enemy.lastShotTime > 1000) { // Shotgun cooldown
                enemy.lastShotTime = currentTime;
                const distance = enemy.position.distanceTo(playerPosition);
                if (distance < 150) { // Only shoot if the player is close
                    // Create a bullet for the enemy
                    const enemyBulletGeometry = new THREE.SphereGeometry(2, 8, 8);
                    const enemyBulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red bullet for the enemy
                    const enemyBullet = new THREE.Mesh(enemyBulletGeometry, enemyBulletMaterial);

                    // Position the bullet at the enemy's location
                    enemyBullet.position.copy(enemy.position);
                    enemyBullet.position.y += 20; // Adjust bullet origin to enemy's center

                    // Set bullet velocity to move towards player
                    const enemyBulletDirection = new THREE.Vector3().subVectors(playerPosition, enemy.position);
                    enemyBulletDirection.normalize();
                    enemyBullet.velocity = enemyBulletDirection.multiplyScalar(500); // Slower bullet speed for enemies

                    scene.add(enemyBullet);
                    enemyBullets.push(enemyBullet);
                }
            }
        });
    }

    // Update bullets and check for collisions
    function updateBullets(delta) {
        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            
            // Move bullet
            bullet.position.addScaledVector(bullet.velocity, delta);

            // Check for collision with enemies
            let hit = false;
            for (let j = enemies.length - 1; j >= 0; j--) {
                const enemy = enemies[j];
                const distance = bullet.position.distanceTo(enemy.position);

                if (distance < 20) { // Collision detected
                    // Use damage from the current weapon
                    enemy.health -= weapons[currentWeaponIndex].damage; 
                    
                    if (enemy.health <= 0) {
                        scene.remove(enemy);
                        enemies.splice(j, 1);
                    }
                    hit = true;
                    break;
                }
            }

            // Remove bullet if it hit something or went too far
            if (hit || bullet.position.length() > 1000) {
                scene.remove(bullet);
                bullets.splice(i, 1);
            }
        }
    }

    // Update enemy bullets and check for collision with player
    function updateEnemyBullets(delta) {
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
            const bullet = enemyBullets[i];
            
            // Move bullet
            bullet.position.addScaledVector(bullet.velocity, delta);
            
            // Check for collision with player
            const playerPosition = controls.getObject().position;
            const distance = bullet.position.distanceTo(playerPosition);
            
            let hit = false;
            if (distance < 20) { // Collision detected with player
                takeDamage(10); // Player takes 10 damage
                showMessage(`Zasiahol ťa nepriateľ!`);
                hit = true;
            }

            // Remove bullet if it hit something or went too far
            if (hit || bullet.position.length() > 1000) {
                scene.remove(bullet);
                enemyBullets.splice(i, 1);
            }
        }
    }

    // Player damage logic
    function takeDamage(amount) {
        playerHealth -= amount;
        if (playerHealth < 0) playerHealth = 0;
        healthBarFill.style.width = `${playerHealth}%`;
        if (playerHealth <= 0) {
            gameOver();
        }
    }

    // Game over logic
    function gameOver() {
        isGameOver = true;
        controls.unlock();
        showMessage("Zomrel si! Znovuzrodenie...", 3000);
            
        // Wait for 3 seconds before respawning
        setTimeout(() => {
            // Reset player health
            playerHealth = 100;
            healthBarFill.style.width = `${playerHealth}%`;

            // Reset player position
            controls.getObject().position.set(0, playerHeight, 0);

            // Clear all enemy bullets to avoid instant re-death
            enemyBullets.forEach(bullet => scene.remove(bullet));
            enemyBullets = [];

            // Reset game over flag and re-lock controls
            isGameOver = false;
            controls.lock();
        }, 3000); // 3-second delay
    }

    // Keyboard input handling
    function onKeyDown(event) {
        switch (event.code) {
            case 'KeyW':
            case 'ArrowUp':
                moveForward = true;
                break;
            case 'KeyA':
            case 'ArrowLeft':
                moveLeft = true;
                break;
            case 'KeyS':
            case 'ArrowDown':
                moveBackward = true;
                break;
            case 'KeyD':
            case 'ArrowRight':
                moveRight = true;
                break;
            case 'Space':
                if (canJump === true) velocity.y += 350;
                canJump = false;
                break;
            default:
                if (event.code.startsWith('Digit')) {
                    const digit = parseInt(event.code.slice(5), 10);
                    if (digit >= 1 && digit <= weapons.length) {
                        currentWeaponIndex = digit - 1;
                        updateWeapon();
                    }
                }
                break;
        }
    }

    function onKeyUp(event) {
        switch (event.code) {
            case 'KeyW':
            case 'ArrowUp':
                moveForward = false;
                break;
            case 'KeyA':
            case 'ArrowLeft':
                moveLeft = false;
                break;
            case 'KeyS':
            case 'ArrowDown':
                moveBackward = false;
                break;
            case 'KeyD':
            case 'ArrowRight':
                moveRight = false;
                break;
        }
    }

    // Animation loop
    let prevTime = performance.now();
    function animate() {
        requestAnimationFrame(animate);

        const currentTime = performance.now();
        const delta = (currentTime - prevTime) / 1000;

        if (controls.isLocked === true && !isGameOver) {
            // Spawn enemies on a timer
            if (currentTime - lastEnemySpawn > enemySpawnInterval) {
                spawnEnemies();
                lastEnemySpawn = currentTime;
            }

            // Apply gravity
            velocity.y -= 9.8 * 100.0 * delta;

            // Player horizontal movement
            // Pohyb sa teraz nasobi koeficientom rychlosti zbrane
            const currentWeapon = weapons[currentWeaponIndex];
            const currentSpeed = speed * currentWeapon.speedMultiplier;

            const horizontalVelocity = new THREE.Vector3();
            if (moveForward) horizontalVelocity.z += currentSpeed;
            if (moveBackward) horizontalVelocity.z -= currentSpeed;
            if (moveLeft) horizontalVelocity.x -= currentSpeed;
            if (moveRight) horizontalVelocity.x += currentSpeed;

            controls.moveRight(horizontalVelocity.x * delta);
            controls.moveForward(horizontalVelocity.z * delta);

            // Apply vertical movement (jumping and gravity)
            controls.getObject().position.y += velocity.y * delta;

            if (controls.getObject().position.y < playerHeight) {
                velocity.y = 0;
                controls.getObject().position.y = playerHeight;
                canJump = true;
            }

            // Update enemies and bullets
            updateEnemies(delta);
            updateBullets(delta); 
            updateEnemyBullets(delta); 
        }

        prevTime = currentTime;
        renderer.render(scene, camera);
    }

    // Start the game when the window loads
    window.onload = init;
</script>

</body>
</html>
